// File: graph.cpp
// -- simple graph handling source file
//-----------------------------------------------------------------------------
// Community detection
// Based on the article "Fast unfolding of community hierarchies in large networks"
// Copyright (C) 2008 V. Blondel, J.-L. Guillaume, R. Lambiotte, E. Lefebvre
//
// This program must not be distributed without agreement of the above mentionned authors.
//-----------------------------------------------------------------------------
// Author   : E. Lefebvre, adapted by J.-L. Guillaume
// Email    : jean-loup.guillaume@lip6.fr
// Location : Paris, France
// Time	    : February 2008
//-----------------------------------------------------------------------------
// see readme.txt for more details

#include<string.h>
#include "../include/graph.h"

using namespace std;

Graph::Graph(char *filename, int type, bool do_renumber) {
  ifstream finput;
 // finput.open(filename,fstream::in);
  
  if(do_renumber) {	
  
  unsigned int src, dest, cpt;
  cpt = 0;

	unsigned int src_prec, dest_prec;
        src_prec = -1;
        dest_prec = -1;
        
  int nb_links=0;
  double weight = 1.;
  ofstream foutput;


		cout << "Renumerotation begins..." << endl;
		
		correspondance.resize(0);

	/* Find minimum and maximum value of ids */
      unsigned int min, maxi;

        if(type == WEIGHTED)
                finput >> src >> dest >> weight;
        else
                finput >> src >> dest;

        min = src;
        maxi = dest;

        while(!finput.eof()) {

                finput >> src >> dest;

                if(min > src)
                        min = src;
                if(min > dest)
                        min = dest;

                if(maxi < src)
                        maxi = src;
                if(maxi < dest)
                        maxi = dest;

        }

        finput.close();
	cout << "Maximum found : " << maxi << endl;

        /* Creating a bunch of maps */
        vector<map<unsigned int, unsigned int> > corres;
        int interval = 1000;

	corres.resize((maxi/interval)+1);
        unsigned int nb_interval_src, nb_interval_dest;

        finput.open(filename,fstream::in);

        if(finput) {

        while(!finput.eof()) {

			if(finput.eof()) 

				break;

                        if(type == WEIGHTED)
                                finput >> src >> dest >> weight;
                        else
                                finput >> src >> dest;

			 			if(src_prec == src && dest_prec == dest)

                                continue;

			nb_interval_src = src / interval;
                        if(corres[nb_interval_src].find(src) == corres[nb_interval_src].end()) {
				corres[nb_interval_src].insert(make_pair(src, cpt));
                                correspondance.resize(correspondance.size()+1);
                                correspondance[cpt] = src;
                                cpt++;

                        }

			nb_interval_dest = dest / interval;
                        if(corres[nb_interval_dest].find(dest) == corres[nb_interval_dest].end()) {
				corres[nb_interval_dest].insert(make_pair(dest, cpt));
                                correspondance.resize(correspondance.size()+1);
                                correspondance[cpt] = dest;
                                cpt++;

                        }
                        
<<<<<<< .mine
			if (cpt % 100000 == 0)
				cout << cpt << " sommet renumérotés " << endl;
                        /* On ecrit l'arc */
                        /* On agrandit la liste des voisins en fonction de l'identifiant lu */
=======
>>>>>>> .r104
					    
					    	map<unsigned int, unsigned int>::iterator it_src;
					    	map<unsigned int, unsigned int>::iterator it_dest;
					    
					    	it_src = corres[nb_interval_src].find(src);
                                                it_dest = corres[nb_interval_dest].find(dest);

						unsigned int pos_src = it_src->second;
						unsigned int pos_dest = it_dest->second;
	
					      if (links_out.size()<=max(pos_src,pos_dest)+1) {
					        links_out.resize(max(pos_src,pos_dest)+1);
					      }
						if(links_in.size()<=max(pos_src,pos_dest)+1) {
							links_in.resize(max(pos_src,pos_dest)+1);
						}
					      
					      links_out[pos_src].push_back(make_pair(pos_dest,weight));
					      links_in[pos_dest].push_back(make_pair(pos_src,weight));
					
					      nb_links++;
	
		// TODO: count nb_links while parsing for the maximum, and pourcent the progression 			
		if(nb_links % 10000000 == 0) cout << "10000000 ecrits" << endl;


                     	src_prec = src;
                        dest_prec = dest;

                }

        }
	finput.close();

	cout << "Renumerotation ends..." << endl;


}
else {

int src, dest, cpt;
  cpt = 0;

        int src_prec, dest_prec;
        src_prec = -1;
        dest_prec = -1;
        
  int nb_links=0;
  double weight = 1.;

                
        if(finput) {

        while(!finput.eof()) {

                        if(finput.eof())

                                break;

                        if(type == WEIGHTED)
                                finput >> src >> dest >> weight;
                        else
                                finput >> src >> dest;

                                                if(src_prec == src && dest_prec == dest)

                                continue;

			if (links_out.size()<=max(src,dest)+1) {
                                                links_out.resize(max(src,dest)+1);
                                              }
                                                if(links_in.size()<=max(src,dest)+1) {
                                                        links_in.resize(max(src,dest)+1);
                                                }
                                              
                                        
                                              links_out[src].push_back(make_pair(dest,weight));
                                              links_in[dest].push_back(make_pair(src,weight));
                                              /* TODO: rajouter links_out_in si on veut aussi les voisins entrants */
                                              /* Duplication du lien. Genant pour les orientes */
                                              //if (src!=dest)
                                              //        links_out[dest].push_back(make_pair(src,weight));
                                        
                                              nb_links++;

                        src_prec = src;
                        dest_prec = dest;

}}}
    
  finput.close();

}

/* Permet de gerer les multigraphes : si on a dans le fichier 1 4 3 et 1 4 6, 
 * le graphe original aura deux paires (4,3) et (4,6) dans la liste d'adjacence 
 * de 1. Du coup, cette procedure remplacera ca par (4,9). 
 * UTILE UNIQUEMENT EN ORIENTE, DONC INUTILE.
 */
void
Graph::clean(int type) {
  for (unsigned int i=0 ; i<links_out.size() ; i++) {
    map<int, float> m;
    map<int, float>::iterator it;

    for (unsigned int j=0 ; j<links_out[i].size() ; j++) {
      it = m.find(links_out[i][j].first);
      if (it==m.end())
	m.insert(make_pair(links_out[i][j].first, links_out[i][j].second));
      else if (type==WEIGHTED)
      	it->second+=links_out[i][j].second;
    }
    
    vector<pair<int,float> > v;
    for (it = m.begin() ; it!=m.end() ; it++)
      v.push_back(*it);
    links_out[i].clear();
    links_out[i]=v;
  }
}

void
Graph::display(int type) {
  for (unsigned int i=0 ; i<links_out.size() ; i++) {
    for (unsigned int j=0 ; j<links_out[i].size() ; j++) {
      int dest   = links_out[i][j].first;
      float weight = links_out[i][j].second;
      if (type==WEIGHTED)
	cout << i << " " << dest << " " << weight << endl;
      else
	cout << i << " " << dest << endl;
    }
  }
}

void
Graph::displayFile(string filename, int type) {
  ofstream foutput;
  foutput.open(filename.c_str(), fstream::out);
  for (unsigned int i=0 ; i<links_out.size() ; i++) {
    for (unsigned int j=0 ; j<links_out[i].size() ; j++) {
      int dest   = links_out[i][j].first;
      float weight = links_out[i][j].second;
      if (type==WEIGHTED)
	foutput << correspondance[i] << " " << correspondance[dest] << " " << weight << endl;
      else
	foutput << correspondance[i] << " " << correspondance[dest] << endl;
    }
  }
  foutput.close();
}

void
Graph::display_binary(char *filename, char *filename_w, int type) {
  ofstream foutput;
  foutput.open(filename, fstream::out | fstream::binary);

  unsigned int s = links_out.size();

  // outputs number of nodes
  foutput.write((char *)(&s),4);

  // outputs cumulative degree sequence
  /* Contient uniquement les degres sortants en oriente */
  long tot=0;
  for (unsigned int i=0 ; i<s ; i++) {
      tot+=(long)links_out[i].size();
    foutput.write((char *)(&tot),4);
  }

  // outputs cumulative degree sequence
  /* Contient uniquement les degres entrants en oriente */
  long tot_in=0;
  for (unsigned int i=0 ; i<s ; i++) {
    	tot_in+=(long)links_in[i].size();
    foutput.write((char *)(&tot_in),4);
  }
  
  // outputs correspondance 
  for(unsigned int i = 0; i <s ; i++) {
  	
  		int corr = correspondance[i];
		foutput.write((char *)(&corr),4);
  	
  } 

  // outputs links_out
  for (unsigned int i=0 ; i<s ; i++) {
    for (unsigned int j=0 ; j<links_out[i].size() ; j++) {
      int dest = links_out[i][j].first;
      foutput.write((char *)(&dest),4);
    }
  }

  // outputs links_in
  for (unsigned int i=0 ; i<s ; i++) {
    for (unsigned int j=0 ; j<links_in[i].size() ; j++) {
      int dest = links_in[i][j].first;
      foutput.write((char *)(&dest),4);
    }
  }
  foutput.close();
  
  // outputs weights in a separate file
  if (type==WEIGHTED) {
    ofstream foutput_w;
    foutput_w.open(filename_w,fstream::out | fstream::binary);
    for (unsigned int i=0 ; i<s ; i++) {
      for (unsigned int j=0 ; j<links_out[i].size() ; j++) {
	float weight = links_out[i][j].second;
	foutput_w.write((char *)(&weight),4);
      }
    }
    foutput_w.close();
  }
}

